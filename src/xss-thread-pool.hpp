/*******************************************************************
 * Copyright (C) 2025 Intel Corporation
 * SPDX-License-Identifier: BSD-3-Clause
 * Authors: Raghuveer Devulapalli <raghuveer.devulapalli@intel.com>
 * ****************************************************************/

#ifndef XSS_THREAD_POOL
#define XSS_THREAD_POOL

#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>
#include <functional>
#include <future>
#include <vector>
#include <atomic>

/*
 * ThreadPool class and doc: Generated by copilot
 * This thread pool implementation is a simple and efficient way to manage a
 * pool of threads for executing tasks concurrently. It uses a std::queue to store
 * tasks and a set of worker threads which wait for tasks to be added to the
 * queue. When a task is added, one of the worker threads will pick it up and
 * execute it. The thread pool can be stopped gracefully, and it also provides
 * a way to wait for all tasks to complete before stopping.
 * */
class ThreadPool {
private:
    std::vector<std::thread> workers;
    std::queue<std::function<void()>> tasks;
    std::mutex queue_mutex;
    std::condition_variable condition; // Condition variable for task queue
    std::condition_variable done_condition; // Condition variable for waiting
    int active_tasks {0};
    bool stop;

public:
    ThreadPool(size_t num_threads) : stop(false)
    {
        for (size_t i = 0; i < num_threads; ++i) {
            // Create a worker thread and add it to the pool
            // Each thread will run a lambda function that waits for tasks
            workers.emplace_back([this] {
                while (true) {
                    // Lock the queue mutex and wait for a task to be available
                    std::unique_lock<std::mutex> lock(queue_mutex);
                    // Wait until there is a task or the pool is stopped
                    condition.wait(lock,
                                   [this] { return stop || !tasks.empty(); });

                    // Check if we need to terminate the thread
                    if (stop && tasks.empty()) { return; }

                    // Extract the next task from the queue
                    auto task = std::move(tasks.front());
                    tasks.pop();
                    // Unlock the mutex before executing the task
                    lock.unlock();
                    // Execute the task:
                    task();
                }
            });
        }
    }

    template <class F>
    void enqueue(F &&func)
    {
        // Add a new task to the queue and notify one of the worker threads
        std::unique_lock<std::mutex> lock(queue_mutex);
        tasks.emplace(std::forward<F>(func));
        condition.notify_one();
    }

    ~ThreadPool()
    {
        // Stop the thread pool and join all threads
        std::unique_lock<std::mutex> lock(queue_mutex);
        stop = true;
        lock.unlock();
        condition.notify_all();
        for (std::thread &worker : workers) {
            worker.join();
        }
    }

    // Wait for all tasks to complete before stopping the pool
    void wait_all()
    {
        std::unique_lock<std::mutex> lock(queue_mutex);
        done_condition.wait(
                lock, [this] { return tasks.empty() && (active_tasks == 0); });
        // lock is automatically released here
    }

    // Track the number of active tasks
    void task_start()
    {
        std::unique_lock<std::mutex> lock(queue_mutex);
        active_tasks++;
        // lock is automatically released here
    }

    // Decrement the active task count and notify if all tasks are done
    void task_end()
    {
        std::unique_lock<std::mutex> lock(queue_mutex);
        active_tasks--;
        if (tasks.empty() && active_tasks == 0) { done_condition.notify_all(); }
        // lock is automatically released here
    }
};

// Wrapper for submitting tasks to the thread pool with automatic tracking
template <typename F>
void submit_task(ThreadPool &pool, F &&f)
{
    pool.task_start();
    pool.enqueue([f = std::forward<F>(f), &pool]() {
        f();
        pool.task_end();
    });
}

#endif // XSS_THREAD_POOL
